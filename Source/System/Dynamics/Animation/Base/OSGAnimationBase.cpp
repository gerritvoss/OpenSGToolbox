/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact:  David Kabala (djkabala@gmail.com)                             *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Animation!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include "OSGConfig.h"




#include "OSGAnimationBase.h"
#include "OSGAnimation.h"

#include <boost/bind.hpp>

#include "OSGEventDetails.h"

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Animation
    \brief Abstract interface for controlling and applying the result of an
    #OSG::Animator to some object

    To use an animation, first create a concrete instance that
    inherits from Animation.  The animation can be started using the start()
    method.  Updating the animation can be done using the update() method, or
    preferably by attaching an UpdateEvent producer using the
    attachUpdateProducer() method.<br>

    Classes that inherit from Animation must implement the public
    getUnclippedLength() and protected internalUpdate() methods.  internalUpdate() is
    responsible for applying the result of an #OSG::Animator to some object.  The
    concrete class can define what object to apply to.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var Int32           AnimationBase::_sfCycling
    
*/

/*! \var Real32          AnimationBase::_sfScale
    
*/

/*! \var Real32          AnimationBase::_sfOffset
    
*/

/*! \var Real32          AnimationBase::_sfSpan
    
*/

/*! \var Real32          AnimationBase::_sfCycles
    
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<Animation *>::_type("AnimationPtr", "AttachmentContainerPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(Animation *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           Animation *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           Animation *,
                           0);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void AnimationBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "Cycling",
        "",
        CyclingFieldId, CyclingFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Animation::editHandleCycling),
        static_cast<FieldGetMethodSig >(&Animation::getHandleCycling));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "Scale",
        "",
        ScaleFieldId, ScaleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Animation::editHandleScale),
        static_cast<FieldGetMethodSig >(&Animation::getHandleScale));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "Offset",
        "",
        OffsetFieldId, OffsetFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Animation::editHandleOffset),
        static_cast<FieldGetMethodSig >(&Animation::getHandleOffset));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "Span",
        "",
        SpanFieldId, SpanFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Animation::editHandleSpan),
        static_cast<FieldGetMethodSig >(&Animation::getHandleSpan));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "Cycles",
        "",
        CyclesFieldId, CyclesFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Animation::editHandleCycles),
        static_cast<FieldGetMethodSig >(&Animation::getHandleCycles));

    oType.addInitialDesc(pDesc);
}


AnimationBase::TypeObject AnimationBase::_type(
    AnimationBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    NULL,
    Animation::initMethod,
    Animation::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&Animation::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"Animation\"\n"
    "\tparent=\"AttachmentContainer\"\n"
    "    library=\"TBAnimation\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"abstract\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "    isNodeCore=\"false\"\n"
    "    authors=\"David Kabala (djkabala@gmail.com)                             \"\n"
    ">\n"
    "\\brief Abstract interface for controlling and applying the result of an\n"
    "#OSG::Animator to some object\n"
    "\n"
    "\\copybrief OSG::Animation\n"
    "To use an animation, first create a concrete instance that\n"
    "inherits from Animation.  The animation can be started using the start()\n"
    "method.  Updating the animation can be done using the update() method, or\n"
    "preferably by attaching an UpdateEvent producer using the\n"
    "attachUpdateProducer() method.&lt;br&gt;\n"
    "\n"
    "Classes that inherit from Animation must implement the public\n"
    "getUnclippedLength() and protected internalUpdate() methods.  internalUpdate() is\n"
    "responsible for applying the result of an #OSG::Animator to some object.  The\n"
    "concrete class can define what object to apply to.\n"
    "\t<Field\n"
    "\t\tname=\"Cycling\"\n"
    "\t\ttype=\"Int32\"\n"
    "        category=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        defaultValue=\"-1\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"Scale\"\n"
    "\t\ttype=\"Real32\"\n"
    "        category=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        defaultValue=\"1.0\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"Offset\"\n"
    "\t\ttype=\"Real32\"\n"
    "        category=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        defaultValue=\"0.0\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"Span\"\n"
    "\t\ttype=\"Real32\"\n"
    "        category=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        defaultValue=\"-1.0\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"Cycles\"\n"
    "\t\ttype=\"Real32\"\n"
    "        category=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<ProducedEvent\n"
    "\t\tname=\"AnimationStarted\"\n"
    "\t\tdetailsType=\"AnimationEventDetails\"\n"
    "\t\tconsumable=\"true\"\n"
    "\t>\n"
    "\t</ProducedEvent>\n"
    "\t<ProducedEvent\n"
    "\t\tname=\"AnimationStopped\"\n"
    "\t\tdetailsType=\"AnimationEventDetails\"\n"
    "\t\tconsumable=\"true\"\n"
    "\t>\n"
    "\t</ProducedEvent>\n"
    "\t<ProducedEvent\n"
    "\t\tname=\"AnimationPaused\"\n"
    "\t\tdetailsType=\"AnimationEventDetails\"\n"
    "\t\tconsumable=\"true\"\n"
    "\t>\n"
    "\t</ProducedEvent>\n"
    "\t<ProducedEvent\n"
    "\t\tname=\"AnimationUnpaused\"\n"
    "\t\tdetailsType=\"AnimationEventDetails\"\n"
    "\t\tconsumable=\"true\"\n"
    "\t>\n"
    "\t</ProducedEvent>\n"
    "\t<ProducedEvent\n"
    "\t\tname=\"AnimationEnded\"\n"
    "\t\tdetailsType=\"AnimationEventDetails\"\n"
    "\t\tconsumable=\"true\"\n"
    "\t>\n"
    "\t</ProducedEvent>\n"
    "\t<ProducedEvent\n"
    "\t\tname=\"AnimationCycled\"\n"
    "\t\tdetailsType=\"AnimationEventDetails\"\n"
    "\t\tconsumable=\"true\"\n"
    "\t>\n"
    "\t</ProducedEvent>\n"
    "</FieldContainer>\n",
    "\\brief Abstract interface for controlling and applying the result of an\n"
    "#OSG::Animator to some object\n"
    "\n"
    "\\copybrief OSG::Animation\n"
    "To use an animation, first create a concrete instance that\n"
    "inherits from Animation.  The animation can be started using the start()\n"
    "method.  Updating the animation can be done using the update() method, or\n"
    "preferably by attaching an UpdateEvent producer using the\n"
    "attachUpdateProducer() method.<br>\n"
    "\n"
    "Classes that inherit from Animation must implement the public\n"
    "getUnclippedLength() and protected internalUpdate() methods.  internalUpdate() is\n"
    "responsible for applying the result of an #OSG::Animator to some object.  The\n"
    "concrete class can define what object to apply to.\n"
    );

//! Animation Produced Events

EventDescription *AnimationBase::_eventDesc[] =
{
    new EventDescription("AnimationStarted", 
                          "",
                          AnimationStartedEventId, 
                          FieldTraits<AnimationEventDetails *>::getType(),
                          true,
                          static_cast<EventGetMethod>(&AnimationBase::getHandleAnimationStartedSignal)),

    new EventDescription("AnimationStopped", 
                          "",
                          AnimationStoppedEventId, 
                          FieldTraits<AnimationEventDetails *>::getType(),
                          true,
                          static_cast<EventGetMethod>(&AnimationBase::getHandleAnimationStoppedSignal)),

    new EventDescription("AnimationPaused", 
                          "",
                          AnimationPausedEventId, 
                          FieldTraits<AnimationEventDetails *>::getType(),
                          true,
                          static_cast<EventGetMethod>(&AnimationBase::getHandleAnimationPausedSignal)),

    new EventDescription("AnimationUnpaused", 
                          "",
                          AnimationUnpausedEventId, 
                          FieldTraits<AnimationEventDetails *>::getType(),
                          true,
                          static_cast<EventGetMethod>(&AnimationBase::getHandleAnimationUnpausedSignal)),

    new EventDescription("AnimationEnded", 
                          "",
                          AnimationEndedEventId, 
                          FieldTraits<AnimationEventDetails *>::getType(),
                          true,
                          static_cast<EventGetMethod>(&AnimationBase::getHandleAnimationEndedSignal)),

    new EventDescription("AnimationCycled", 
                          "",
                          AnimationCycledEventId, 
                          FieldTraits<AnimationEventDetails *>::getType(),
                          true,
                          static_cast<EventGetMethod>(&AnimationBase::getHandleAnimationCycledSignal))

};

EventProducerType AnimationBase::_producerType(
    "AnimationProducerType",
    "EventProducerType",
    "",
    InitEventProducerFunctor(),
    _eventDesc,
    sizeof(_eventDesc));

/*------------------------------ get -----------------------------------*/

FieldContainerType &AnimationBase::getType(void)
{
    return _type;
}

const FieldContainerType &AnimationBase::getType(void) const
{
    return _type;
}

const EventProducerType &AnimationBase::getProducerType(void) const
{
    return _producerType;
}

UInt32 AnimationBase::getContainerSize(void) const
{
    return sizeof(Animation);
}

/*------------------------- decorator get ------------------------------*/


SFInt32 *AnimationBase::editSFCycling(void)
{
    editSField(CyclingFieldMask);

    return &_sfCycling;
}

const SFInt32 *AnimationBase::getSFCycling(void) const
{
    return &_sfCycling;
}


SFReal32 *AnimationBase::editSFScale(void)
{
    editSField(ScaleFieldMask);

    return &_sfScale;
}

const SFReal32 *AnimationBase::getSFScale(void) const
{
    return &_sfScale;
}


SFReal32 *AnimationBase::editSFOffset(void)
{
    editSField(OffsetFieldMask);

    return &_sfOffset;
}

const SFReal32 *AnimationBase::getSFOffset(void) const
{
    return &_sfOffset;
}


SFReal32 *AnimationBase::editSFSpan(void)
{
    editSField(SpanFieldMask);

    return &_sfSpan;
}

const SFReal32 *AnimationBase::getSFSpan(void) const
{
    return &_sfSpan;
}


SFReal32 *AnimationBase::editSFCycles(void)
{
    editSField(CyclesFieldMask);

    return &_sfCycles;
}

const SFReal32 *AnimationBase::getSFCycles(void) const
{
    return &_sfCycles;
}






/*------------------------------ access -----------------------------------*/

UInt32 AnimationBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (CyclingFieldMask & whichField))
    {
        returnValue += _sfCycling.getBinSize();
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        returnValue += _sfScale.getBinSize();
    }
    if(FieldBits::NoField != (OffsetFieldMask & whichField))
    {
        returnValue += _sfOffset.getBinSize();
    }
    if(FieldBits::NoField != (SpanFieldMask & whichField))
    {
        returnValue += _sfSpan.getBinSize();
    }
    if(FieldBits::NoField != (CyclesFieldMask & whichField))
    {
        returnValue += _sfCycles.getBinSize();
    }

    return returnValue;
}

void AnimationBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (CyclingFieldMask & whichField))
    {
        _sfCycling.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OffsetFieldMask & whichField))
    {
        _sfOffset.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpanFieldMask & whichField))
    {
        _sfSpan.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CyclesFieldMask & whichField))
    {
        _sfCycles.copyToBin(pMem);
    }
}

void AnimationBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (CyclingFieldMask & whichField))
    {
        _sfCycling.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OffsetFieldMask & whichField))
    {
        _sfOffset.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpanFieldMask & whichField))
    {
        _sfSpan.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CyclesFieldMask & whichField))
    {
        _sfCycles.copyFromBin(pMem);
    }
}



/*------------------------- event producers ----------------------------------*/
void AnimationBase::produceEvent(UInt32 eventId, EventDetails* const e)
{
    switch(eventId)
    {
    case AnimationStartedEventId:
        OSG_ASSERT(dynamic_cast<AnimationStartedEventDetailsType* const>(e));

        _AnimationStartedEvent.set_combiner(ConsumableEventCombiner(e));
        _AnimationStartedEvent(dynamic_cast<AnimationStartedEventDetailsType* const>(e), AnimationStartedEventId);
        break;
    case AnimationStoppedEventId:
        OSG_ASSERT(dynamic_cast<AnimationStoppedEventDetailsType* const>(e));

        _AnimationStoppedEvent.set_combiner(ConsumableEventCombiner(e));
        _AnimationStoppedEvent(dynamic_cast<AnimationStoppedEventDetailsType* const>(e), AnimationStoppedEventId);
        break;
    case AnimationPausedEventId:
        OSG_ASSERT(dynamic_cast<AnimationPausedEventDetailsType* const>(e));

        _AnimationPausedEvent.set_combiner(ConsumableEventCombiner(e));
        _AnimationPausedEvent(dynamic_cast<AnimationPausedEventDetailsType* const>(e), AnimationPausedEventId);
        break;
    case AnimationUnpausedEventId:
        OSG_ASSERT(dynamic_cast<AnimationUnpausedEventDetailsType* const>(e));

        _AnimationUnpausedEvent.set_combiner(ConsumableEventCombiner(e));
        _AnimationUnpausedEvent(dynamic_cast<AnimationUnpausedEventDetailsType* const>(e), AnimationUnpausedEventId);
        break;
    case AnimationEndedEventId:
        OSG_ASSERT(dynamic_cast<AnimationEndedEventDetailsType* const>(e));

        _AnimationEndedEvent.set_combiner(ConsumableEventCombiner(e));
        _AnimationEndedEvent(dynamic_cast<AnimationEndedEventDetailsType* const>(e), AnimationEndedEventId);
        break;
    case AnimationCycledEventId:
        OSG_ASSERT(dynamic_cast<AnimationCycledEventDetailsType* const>(e));

        _AnimationCycledEvent.set_combiner(ConsumableEventCombiner(e));
        _AnimationCycledEvent(dynamic_cast<AnimationCycledEventDetailsType* const>(e), AnimationCycledEventId);
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        break;
    }
}

boost::signals2::connection AnimationBase::connectEvent(UInt32 eventId, 
                                                             const BaseEventType::slot_type &listener, 
                                                             boost::signals2::connect_position at)
{
    switch(eventId)
    {
    case AnimationStartedEventId:
        return _AnimationStartedEvent.connect(listener, at);
        break;
    case AnimationStoppedEventId:
        return _AnimationStoppedEvent.connect(listener, at);
        break;
    case AnimationPausedEventId:
        return _AnimationPausedEvent.connect(listener, at);
        break;
    case AnimationUnpausedEventId:
        return _AnimationUnpausedEvent.connect(listener, at);
        break;
    case AnimationEndedEventId:
        return _AnimationEndedEvent.connect(listener, at);
        break;
    case AnimationCycledEventId:
        return _AnimationCycledEvent.connect(listener, at);
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        return boost::signals2::connection();
        break;
    }

    return boost::signals2::connection();
}

boost::signals2::connection  AnimationBase::connectEvent(UInt32 eventId, 
                                                              const BaseEventType::group_type &group,
                                                              const BaseEventType::slot_type &listener,
                                                              boost::signals2::connect_position at)
{
    switch(eventId)
    {
    case AnimationStartedEventId:
        return _AnimationStartedEvent.connect(group, listener, at);
        break;
    case AnimationStoppedEventId:
        return _AnimationStoppedEvent.connect(group, listener, at);
        break;
    case AnimationPausedEventId:
        return _AnimationPausedEvent.connect(group, listener, at);
        break;
    case AnimationUnpausedEventId:
        return _AnimationUnpausedEvent.connect(group, listener, at);
        break;
    case AnimationEndedEventId:
        return _AnimationEndedEvent.connect(group, listener, at);
        break;
    case AnimationCycledEventId:
        return _AnimationCycledEvent.connect(group, listener, at);
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        return boost::signals2::connection();
        break;
    }

    return boost::signals2::connection();
}
    
void  AnimationBase::disconnectEvent(UInt32 eventId, const BaseEventType::group_type &group)
{
    switch(eventId)
    {
    case AnimationStartedEventId:
        _AnimationStartedEvent.disconnect(group);
        break;
    case AnimationStoppedEventId:
        _AnimationStoppedEvent.disconnect(group);
        break;
    case AnimationPausedEventId:
        _AnimationPausedEvent.disconnect(group);
        break;
    case AnimationUnpausedEventId:
        _AnimationUnpausedEvent.disconnect(group);
        break;
    case AnimationEndedEventId:
        _AnimationEndedEvent.disconnect(group);
        break;
    case AnimationCycledEventId:
        _AnimationCycledEvent.disconnect(group);
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        break;
    }
}

void  AnimationBase::disconnectAllSlotsEvent(UInt32 eventId)
{
    switch(eventId)
    {
    case AnimationStartedEventId:
        _AnimationStartedEvent.disconnect_all_slots();
        break;
    case AnimationStoppedEventId:
        _AnimationStoppedEvent.disconnect_all_slots();
        break;
    case AnimationPausedEventId:
        _AnimationPausedEvent.disconnect_all_slots();
        break;
    case AnimationUnpausedEventId:
        _AnimationUnpausedEvent.disconnect_all_slots();
        break;
    case AnimationEndedEventId:
        _AnimationEndedEvent.disconnect_all_slots();
        break;
    case AnimationCycledEventId:
        _AnimationCycledEvent.disconnect_all_slots();
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        break;
    }
}

bool  AnimationBase::isEmptyEvent(UInt32 eventId) const
{
    switch(eventId)
    {
    case AnimationStartedEventId:
        return _AnimationStartedEvent.empty();
        break;
    case AnimationStoppedEventId:
        return _AnimationStoppedEvent.empty();
        break;
    case AnimationPausedEventId:
        return _AnimationPausedEvent.empty();
        break;
    case AnimationUnpausedEventId:
        return _AnimationUnpausedEvent.empty();
        break;
    case AnimationEndedEventId:
        return _AnimationEndedEvent.empty();
        break;
    case AnimationCycledEventId:
        return _AnimationCycledEvent.empty();
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        return true;
        break;
    }
}

UInt32  AnimationBase::numSlotsEvent(UInt32 eventId) const
{
    switch(eventId)
    {
    case AnimationStartedEventId:
        return _AnimationStartedEvent.num_slots();
        break;
    case AnimationStoppedEventId:
        return _AnimationStoppedEvent.num_slots();
        break;
    case AnimationPausedEventId:
        return _AnimationPausedEvent.num_slots();
        break;
    case AnimationUnpausedEventId:
        return _AnimationUnpausedEvent.num_slots();
        break;
    case AnimationEndedEventId:
        return _AnimationEndedEvent.num_slots();
        break;
    case AnimationCycledEventId:
        return _AnimationCycledEvent.num_slots();
        break;
    default:
        SWARNING << "No event defined with ID " << eventId << std::endl;
        return 0;
        break;
    }
}


/*------------------------- constructors ----------------------------------*/

AnimationBase::AnimationBase(void) :
    Inherited(),
    _sfCycling                (Int32(-1)),
    _sfScale                  (Real32(1.0)),
    _sfOffset                 (Real32(0.0)),
    _sfSpan                   (Real32(-1.0)),
    _sfCycles                 (Real32(0))
{
}

AnimationBase::AnimationBase(const AnimationBase &source) :
    Inherited(source),
    _sfCycling                (source._sfCycling                ),
    _sfScale                  (source._sfScale                  ),
    _sfOffset                 (source._sfOffset                 ),
    _sfSpan                   (source._sfSpan                   ),
    _sfCycles                 (source._sfCycles                 )
{
}


/*-------------------------- destructors ----------------------------------*/

AnimationBase::~AnimationBase(void)
{
}


GetFieldHandlePtr AnimationBase::getHandleCycling         (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfCycling,
             this->getType().getFieldDesc(CyclingFieldId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr AnimationBase::editHandleCycling        (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfCycling,
             this->getType().getFieldDesc(CyclingFieldId),
             this));


    editSField(CyclingFieldMask);

    return returnValue;
}

GetFieldHandlePtr AnimationBase::getHandleScale           (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfScale,
             this->getType().getFieldDesc(ScaleFieldId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr AnimationBase::editHandleScale          (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfScale,
             this->getType().getFieldDesc(ScaleFieldId),
             this));


    editSField(ScaleFieldMask);

    return returnValue;
}

GetFieldHandlePtr AnimationBase::getHandleOffset          (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffset,
             this->getType().getFieldDesc(OffsetFieldId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr AnimationBase::editHandleOffset         (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffset,
             this->getType().getFieldDesc(OffsetFieldId),
             this));


    editSField(OffsetFieldMask);

    return returnValue;
}

GetFieldHandlePtr AnimationBase::getHandleSpan            (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfSpan,
             this->getType().getFieldDesc(SpanFieldId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr AnimationBase::editHandleSpan           (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfSpan,
             this->getType().getFieldDesc(SpanFieldId),
             this));


    editSField(SpanFieldMask);

    return returnValue;
}

GetFieldHandlePtr AnimationBase::getHandleCycles          (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfCycles,
             this->getType().getFieldDesc(CyclesFieldId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr AnimationBase::editHandleCycles         (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfCycles,
             this->getType().getFieldDesc(CyclesFieldId),
             this));


    editSField(CyclesFieldMask);

    return returnValue;
}


GetEventHandlePtr AnimationBase::getHandleAnimationStartedSignal(void) const
{
    GetEventHandlePtr returnValue(
        new  GetTypedEventHandle<AnimationStartedEventType>(
             const_cast<AnimationStartedEventType *>(&_AnimationStartedEvent),
             _producerType.getEventDescription(AnimationStartedEventId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

GetEventHandlePtr AnimationBase::getHandleAnimationStoppedSignal(void) const
{
    GetEventHandlePtr returnValue(
        new  GetTypedEventHandle<AnimationStoppedEventType>(
             const_cast<AnimationStoppedEventType *>(&_AnimationStoppedEvent),
             _producerType.getEventDescription(AnimationStoppedEventId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

GetEventHandlePtr AnimationBase::getHandleAnimationPausedSignal(void) const
{
    GetEventHandlePtr returnValue(
        new  GetTypedEventHandle<AnimationPausedEventType>(
             const_cast<AnimationPausedEventType *>(&_AnimationPausedEvent),
             _producerType.getEventDescription(AnimationPausedEventId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

GetEventHandlePtr AnimationBase::getHandleAnimationUnpausedSignal(void) const
{
    GetEventHandlePtr returnValue(
        new  GetTypedEventHandle<AnimationUnpausedEventType>(
             const_cast<AnimationUnpausedEventType *>(&_AnimationUnpausedEvent),
             _producerType.getEventDescription(AnimationUnpausedEventId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

GetEventHandlePtr AnimationBase::getHandleAnimationEndedSignal(void) const
{
    GetEventHandlePtr returnValue(
        new  GetTypedEventHandle<AnimationEndedEventType>(
             const_cast<AnimationEndedEventType *>(&_AnimationEndedEvent),
             _producerType.getEventDescription(AnimationEndedEventId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}

GetEventHandlePtr AnimationBase::getHandleAnimationCycledSignal(void) const
{
    GetEventHandlePtr returnValue(
        new  GetTypedEventHandle<AnimationCycledEventType>(
             const_cast<AnimationCycledEventType *>(&_AnimationCycledEvent),
             _producerType.getEventDescription(AnimationCycledEventId),
             const_cast<AnimationBase *>(this)));

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void AnimationBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Animation *pThis = static_cast<Animation *>(this);

    pThis->execSync(static_cast<Animation *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif



void AnimationBase::resolveLinks(void)
{
    Inherited::resolveLinks();


}


OSG_END_NAMESPACE
