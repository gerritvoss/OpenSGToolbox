/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *   contact:  David Kabala (djkabala@gmail.com), Daniel Guilliams           *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class ParticleSystem!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include "OSGParticleSystemEventDetails.h"
#include "OSGParticleEventDetails.h"

OSG_BEGIN_NAMESPACE


//! access the type of the class
inline
OSG::FieldContainerType &ParticleSystemBase::getClassType(void)
{
    return _type;
}

//! access the numerical type of the class
inline
OSG::UInt32 ParticleSystemBase::getClassTypeId(void)
{
    return _type.getId();
}
//! access the producer type of the class
inline
const EventProducerType &ParticleSystemBase::getProducerClassType(void)
{
    return _producerType;
}

//! access the producer type id of the class
inline
UInt32 ParticleSystemBase::getProducerClassTypeId(void)
{
    return _producerType.getId();
}

inline
OSG::UInt16 ParticleSystemBase::getClassGroupId(void)
{
    return _type.getGroupId();
}

/*------------------------------ get -----------------------------------*/


//! Get the value of the ParticleSystem::_sfBeacon field.
inline
Node * ParticleSystemBase::getBeacon(void) const
{
    return _sfBeacon.getValue();
}

//! Set the value of the ParticleSystem::_sfBeacon field.
inline
void ParticleSystemBase::setBeacon(Node * const value)
{
    editSField(BeaconFieldMask);

    _sfBeacon.setValue(value);
}
//! Get the value of the ParticleSystem::_sfMaxParticles field.

inline
UInt32 &ParticleSystemBase::editMaxParticles(void)
{
    editSField(MaxParticlesFieldMask);

    return _sfMaxParticles.getValue();
}

//! Get the value of the ParticleSystem::_sfMaxParticles field.
inline
      UInt32  ParticleSystemBase::getMaxParticles(void) const
{
    return _sfMaxParticles.getValue();
}

//! Set the value of the ParticleSystem::_sfMaxParticles field.
inline
void ParticleSystemBase::setMaxParticles(const UInt32 value)
{
    editSField(MaxParticlesFieldMask);

    _sfMaxParticles.setValue(value);
}
//! Get the value of the ParticleSystem::_sfDynamic field.

inline
bool &ParticleSystemBase::editDynamic(void)
{
    editSField(DynamicFieldMask);

    return _sfDynamic.getValue();
}

//! Get the value of the ParticleSystem::_sfDynamic field.
inline
      bool  ParticleSystemBase::getDynamic(void) const
{
    return _sfDynamic.getValue();
}

//! Set the value of the ParticleSystem::_sfDynamic field.
inline
void ParticleSystemBase::setDynamic(const bool value)
{
    editSField(DynamicFieldMask);

    _sfDynamic.setValue(value);
}
//! Get the value of the ParticleSystem::_sfUpdateSecAttribs field.

inline
bool &ParticleSystemBase::editUpdateSecAttribs(void)
{
    editSField(UpdateSecAttribsFieldMask);

    return _sfUpdateSecAttribs.getValue();
}

//! Get the value of the ParticleSystem::_sfUpdateSecAttribs field.
inline
      bool  ParticleSystemBase::getUpdateSecAttribs(void) const
{
    return _sfUpdateSecAttribs.getValue();
}

//! Set the value of the ParticleSystem::_sfUpdateSecAttribs field.
inline
void ParticleSystemBase::setUpdateSecAttribs(const bool value)
{
    editSField(UpdateSecAttribsFieldMask);

    _sfUpdateSecAttribs.setValue(value);
}
//! Get the value of the ParticleSystem::_sfClearVelocities field.

inline
bool &ParticleSystemBase::editClearVelocities(void)
{
    editSField(ClearVelocitiesFieldMask);

    return _sfClearVelocities.getValue();
}

//! Get the value of the ParticleSystem::_sfClearVelocities field.
inline
      bool  ParticleSystemBase::getClearVelocities(void) const
{
    return _sfClearVelocities.getValue();
}

//! Set the value of the ParticleSystem::_sfClearVelocities field.
inline
void ParticleSystemBase::setClearVelocities(const bool value)
{
    editSField(ClearVelocitiesFieldMask);

    _sfClearVelocities.setValue(value);
}
//! Get the value of the ParticleSystem::_sfClearAccelerations field.

inline
bool &ParticleSystemBase::editClearAccelerations(void)
{
    editSField(ClearAccelerationsFieldMask);

    return _sfClearAccelerations.getValue();
}

//! Get the value of the ParticleSystem::_sfClearAccelerations field.
inline
      bool  ParticleSystemBase::getClearAccelerations(void) const
{
    return _sfClearAccelerations.getValue();
}

//! Set the value of the ParticleSystem::_sfClearAccelerations field.
inline
void ParticleSystemBase::setClearAccelerations(const bool value)
{
    editSField(ClearAccelerationsFieldMask);

    _sfClearAccelerations.setValue(value);
}
//! Get the value of the ParticleSystem::_sfLastElapsedTime field.

inline
Time &ParticleSystemBase::editLastElapsedTime(void)
{
    editSField(LastElapsedTimeFieldMask);

    return _sfLastElapsedTime.getValue();
}

//! Get the value of the ParticleSystem::_sfLastElapsedTime field.
inline
const Time &ParticleSystemBase::getLastElapsedTime(void) const
{
    return _sfLastElapsedTime.getValue();
}

//! Set the value of the ParticleSystem::_sfLastElapsedTime field.
inline
void ParticleSystemBase::setLastElapsedTime(const Time &value)
{
    editSField(LastElapsedTimeFieldMask);

    _sfLastElapsedTime.setValue(value);
}
//! Get the value of the ParticleSystem::_sfVolume field.

inline
BoxVolume &ParticleSystemBase::editVolume(void)
{
    editSField(VolumeFieldMask);

    return _sfVolume.getValue();
}

//! Get the value of the ParticleSystem::_sfVolume field.
inline
const BoxVolume &ParticleSystemBase::getVolume(void) const
{
    return _sfVolume.getValue();
}

//! Set the value of the ParticleSystem::_sfVolume field.
inline
void ParticleSystemBase::setVolume(const BoxVolume &value)
{
    editSField(VolumeFieldMask);

    _sfVolume.setValue(value);
}
//! Get the value of the ParticleSystem::_sfMaxParticleSize field.

inline
Vec3f &ParticleSystemBase::editMaxParticleSize(void)
{
    editSField(MaxParticleSizeFieldMask);

    return _sfMaxParticleSize.getValue();
}

//! Get the value of the ParticleSystem::_sfMaxParticleSize field.
inline
const Vec3f &ParticleSystemBase::getMaxParticleSize(void) const
{
    return _sfMaxParticleSize.getValue();
}

//! Set the value of the ParticleSystem::_sfMaxParticleSize field.
inline
void ParticleSystemBase::setMaxParticleSize(const Vec3f &value)
{
    editSField(MaxParticleSizeFieldMask);

    _sfMaxParticleSize.setValue(value);
}

//! Get the value of the \a index element the ParticleSystem::_mfInternalPositions field.
inline
const Pnt3f &ParticleSystemBase::getInternalPositions(const UInt32 index) const
{
    return _mfInternalPositions[index];
}

inline
Pnt3f &ParticleSystemBase::editInternalPositions(const UInt32 index)
{
    editMField(InternalPositionsFieldMask, _mfInternalPositions);

    return _mfInternalPositions[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalSecPositions field.
inline
const Pnt3f &ParticleSystemBase::getInternalSecPositions(const UInt32 index) const
{
    return _mfInternalSecPositions[index];
}

inline
Pnt3f &ParticleSystemBase::editInternalSecPositions(const UInt32 index)
{
    editMField(InternalSecPositionsFieldMask, _mfInternalSecPositions);

    return _mfInternalSecPositions[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalNormals field.
inline
const Vec3f &ParticleSystemBase::getInternalNormals(const UInt32 index) const
{
    return _mfInternalNormals[index];
}

inline
Vec3f &ParticleSystemBase::editInternalNormals(const UInt32 index)
{
    editMField(InternalNormalsFieldMask, _mfInternalNormals);

    return _mfInternalNormals[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalColors field.
inline
const Color4f &ParticleSystemBase::getInternalColors(const UInt32 index) const
{
    return _mfInternalColors[index];
}

inline
Color4f &ParticleSystemBase::editInternalColors(const UInt32 index)
{
    editMField(InternalColorsFieldMask, _mfInternalColors);

    return _mfInternalColors[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalSizes field.
inline
const Vec3f &ParticleSystemBase::getInternalSizes(const UInt32 index) const
{
    return _mfInternalSizes[index];
}

inline
Vec3f &ParticleSystemBase::editInternalSizes(const UInt32 index)
{
    editMField(InternalSizesFieldMask, _mfInternalSizes);

    return _mfInternalSizes[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalLifespans field.
inline
const Time &ParticleSystemBase::getInternalLifespans(const UInt32 index) const
{
    return _mfInternalLifespans[index];
}

inline
Time &ParticleSystemBase::editInternalLifespans(const UInt32 index)
{
    editMField(InternalLifespansFieldMask, _mfInternalLifespans);

    return _mfInternalLifespans[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalAges field.
inline
const Time &ParticleSystemBase::getInternalAges(const UInt32 index) const
{
    return _mfInternalAges[index];
}

inline
Time &ParticleSystemBase::editInternalAges(const UInt32 index)
{
    editMField(InternalAgesFieldMask, _mfInternalAges);

    return _mfInternalAges[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalVelocities field.
inline
const Vec3f &ParticleSystemBase::getInternalVelocities(const UInt32 index) const
{
    return _mfInternalVelocities[index];
}

inline
Vec3f &ParticleSystemBase::editInternalVelocities(const UInt32 index)
{
    editMField(InternalVelocitiesFieldMask, _mfInternalVelocities);

    return _mfInternalVelocities[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalSecVelocities field.
inline
const Vec3f &ParticleSystemBase::getInternalSecVelocities(const UInt32 index) const
{
    return _mfInternalSecVelocities[index];
}

inline
Vec3f &ParticleSystemBase::editInternalSecVelocities(const UInt32 index)
{
    editMField(InternalSecVelocitiesFieldMask, _mfInternalSecVelocities);

    return _mfInternalSecVelocities[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalAccelerations field.
inline
const Vec3f &ParticleSystemBase::getInternalAccelerations(const UInt32 index) const
{
    return _mfInternalAccelerations[index];
}

inline
Vec3f &ParticleSystemBase::editInternalAccelerations(const UInt32 index)
{
    editMField(InternalAccelerationsFieldMask, _mfInternalAccelerations);

    return _mfInternalAccelerations[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalAttributes field.
inline
const StringToUInt32Map &ParticleSystemBase::getInternalAttributes(const UInt32 index) const
{
    return _mfInternalAttributes[index];
}

inline
StringToUInt32Map &ParticleSystemBase::editInternalAttributes(const UInt32 index)
{
    editMField(InternalAttributesFieldMask, _mfInternalAttributes);

    return _mfInternalAttributes[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfInternalIDs field.
inline
      UInt32  ParticleSystemBase::getInternalIDs(const UInt32 index) const
{
    return _mfInternalIDs[index];
}

inline
UInt32 &ParticleSystemBase::editInternalIDs(const UInt32 index)
{
    editMField(InternalIDsFieldMask, _mfInternalIDs);

    return _mfInternalIDs[index];
}


//! Get the value of the \a index element the ParticleSystem::_mfGenerators field.
inline
ParticleGenerator * ParticleSystemBase::getGenerators(const UInt32 index) const
{
    return _mfGenerators[index];
}

//! Get the value of the \a index element the ParticleSystem::_mfAffectors field.
inline
ParticleAffector * ParticleSystemBase::getAffectors(const UInt32 index) const
{
    return _mfAffectors[index];
}

//! Get the value of the \a index element the ParticleSystem::_mfSystemAffectors field.
inline
ParticleSystemAffector * ParticleSystemBase::getSystemAffectors(const UInt32 index) const
{
    return _mfSystemAffectors[index];
}


#ifdef OSG_MT_CPTR_ASPECT
inline
void ParticleSystemBase::execSync (      ParticleSystemBase *pFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Inherited::execSync(pFrom, whichField, oOffsets, syncMode, uiSyncInfo);

    if(FieldBits::NoField != (BeaconFieldMask & whichField))
        _sfBeacon.syncWith(pFrom->_sfBeacon);

    if(FieldBits::NoField != (InternalPositionsFieldMask & whichField))
        _mfInternalPositions.syncWith(pFrom->_mfInternalPositions,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalSecPositionsFieldMask & whichField))
        _mfInternalSecPositions.syncWith(pFrom->_mfInternalSecPositions,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalNormalsFieldMask & whichField))
        _mfInternalNormals.syncWith(pFrom->_mfInternalNormals,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalColorsFieldMask & whichField))
        _mfInternalColors.syncWith(pFrom->_mfInternalColors,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalSizesFieldMask & whichField))
        _mfInternalSizes.syncWith(pFrom->_mfInternalSizes,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalLifespansFieldMask & whichField))
        _mfInternalLifespans.syncWith(pFrom->_mfInternalLifespans,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalAgesFieldMask & whichField))
        _mfInternalAges.syncWith(pFrom->_mfInternalAges,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalVelocitiesFieldMask & whichField))
        _mfInternalVelocities.syncWith(pFrom->_mfInternalVelocities,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalSecVelocitiesFieldMask & whichField))
        _mfInternalSecVelocities.syncWith(pFrom->_mfInternalSecVelocities,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalAccelerationsFieldMask & whichField))
        _mfInternalAccelerations.syncWith(pFrom->_mfInternalAccelerations,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalAttributesFieldMask & whichField))
        _mfInternalAttributes.syncWith(pFrom->_mfInternalAttributes,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (InternalIDsFieldMask & whichField))
        _mfInternalIDs.syncWith(pFrom->_mfInternalIDs,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (MaxParticlesFieldMask & whichField))
        _sfMaxParticles.syncWith(pFrom->_sfMaxParticles);

    if(FieldBits::NoField != (DynamicFieldMask & whichField))
        _sfDynamic.syncWith(pFrom->_sfDynamic);

    if(FieldBits::NoField != (UpdateSecAttribsFieldMask & whichField))
        _sfUpdateSecAttribs.syncWith(pFrom->_sfUpdateSecAttribs);

    if(FieldBits::NoField != (ClearVelocitiesFieldMask & whichField))
        _sfClearVelocities.syncWith(pFrom->_sfClearVelocities);

    if(FieldBits::NoField != (ClearAccelerationsFieldMask & whichField))
        _sfClearAccelerations.syncWith(pFrom->_sfClearAccelerations);

    if(FieldBits::NoField != (LastElapsedTimeFieldMask & whichField))
        _sfLastElapsedTime.syncWith(pFrom->_sfLastElapsedTime);

    if(FieldBits::NoField != (GeneratorsFieldMask & whichField))
        _mfGenerators.syncWith(pFrom->_mfGenerators,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (AffectorsFieldMask & whichField))
        _mfAffectors.syncWith(pFrom->_mfAffectors,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (SystemAffectorsFieldMask & whichField))
        _mfSystemAffectors.syncWith(pFrom->_mfSystemAffectors,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (VolumeFieldMask & whichField))
        _sfVolume.syncWith(pFrom->_sfVolume);

    if(FieldBits::NoField != (MaxParticleSizeFieldMask & whichField))
        _sfMaxParticleSize.syncWith(pFrom->_sfMaxParticleSize);
}
#endif


inline
const Char8 *ParticleSystemBase::getClassname(void)
{
    return "ParticleSystem";
}

inline
UInt32 ParticleSystemBase::getNumProducedEvents(void) const
{
    return getProducerType().getNumEventDescs();
}

inline
const EventDescription *ParticleSystemBase::getProducedEventDescription(const std::string &ProducedEventName) const
{
    return getProducerType().findEventDescription(ProducedEventName);
}

inline
const EventDescription *ParticleSystemBase::getProducedEventDescription(UInt32 ProducedEventId) const
{
    return getProducerType().getEventDescription(ProducedEventId);
}

inline
UInt32 ParticleSystemBase::getProducedEventId(const std::string &ProducedEventName) const
{
    return getProducerType().getProducedEventId(ProducedEventName);
}

inline
boost::signals2::connection  ParticleSystemBase::connectSystemUpdated(const SystemUpdatedEventType::slot_type &listener, 
                                                                               boost::signals2::connect_position at)
{
    return _SystemUpdatedEvent.connect(listener, at);
}

inline
boost::signals2::connection  ParticleSystemBase::connectSystemUpdated(const SystemUpdatedEventType::group_type &group,
                                                    const SystemUpdatedEventType::slot_type &listener, boost::signals2::connect_position at)
{
    return _SystemUpdatedEvent.connect(group, listener, at);
}

inline
void  ParticleSystemBase::disconnectSystemUpdated(const SystemUpdatedEventType::group_type &group)
{
    _SystemUpdatedEvent.disconnect(group);
}

inline
void  ParticleSystemBase::disconnectAllSlotsSystemUpdated(void)
{
    _SystemUpdatedEvent.disconnect_all_slots();
}

inline
bool  ParticleSystemBase::isEmptySystemUpdated(void) const
{
    return _SystemUpdatedEvent.empty();
}

inline
UInt32  ParticleSystemBase::numSlotsSystemUpdated(void) const
{
    return _SystemUpdatedEvent.num_slots();
}

inline
void ParticleSystemBase::produceSystemUpdated(SystemUpdatedEventDetailsType* const e)
{
    produceEvent(SystemUpdatedEventId, e);
}

inline
boost::signals2::connection  ParticleSystemBase::connectVolumeChanged(const VolumeChangedEventType::slot_type &listener, 
                                                                               boost::signals2::connect_position at)
{
    return _VolumeChangedEvent.connect(listener, at);
}

inline
boost::signals2::connection  ParticleSystemBase::connectVolumeChanged(const VolumeChangedEventType::group_type &group,
                                                    const VolumeChangedEventType::slot_type &listener, boost::signals2::connect_position at)
{
    return _VolumeChangedEvent.connect(group, listener, at);
}

inline
void  ParticleSystemBase::disconnectVolumeChanged(const VolumeChangedEventType::group_type &group)
{
    _VolumeChangedEvent.disconnect(group);
}

inline
void  ParticleSystemBase::disconnectAllSlotsVolumeChanged(void)
{
    _VolumeChangedEvent.disconnect_all_slots();
}

inline
bool  ParticleSystemBase::isEmptyVolumeChanged(void) const
{
    return _VolumeChangedEvent.empty();
}

inline
UInt32  ParticleSystemBase::numSlotsVolumeChanged(void) const
{
    return _VolumeChangedEvent.num_slots();
}

inline
void ParticleSystemBase::produceVolumeChanged(VolumeChangedEventDetailsType* const e)
{
    produceEvent(VolumeChangedEventId, e);
}

inline
boost::signals2::connection  ParticleSystemBase::connectParticleGenerated(const ParticleGeneratedEventType::slot_type &listener, 
                                                                               boost::signals2::connect_position at)
{
    return _ParticleGeneratedEvent.connect(listener, at);
}

inline
boost::signals2::connection  ParticleSystemBase::connectParticleGenerated(const ParticleGeneratedEventType::group_type &group,
                                                    const ParticleGeneratedEventType::slot_type &listener, boost::signals2::connect_position at)
{
    return _ParticleGeneratedEvent.connect(group, listener, at);
}

inline
void  ParticleSystemBase::disconnectParticleGenerated(const ParticleGeneratedEventType::group_type &group)
{
    _ParticleGeneratedEvent.disconnect(group);
}

inline
void  ParticleSystemBase::disconnectAllSlotsParticleGenerated(void)
{
    _ParticleGeneratedEvent.disconnect_all_slots();
}

inline
bool  ParticleSystemBase::isEmptyParticleGenerated(void) const
{
    return _ParticleGeneratedEvent.empty();
}

inline
UInt32  ParticleSystemBase::numSlotsParticleGenerated(void) const
{
    return _ParticleGeneratedEvent.num_slots();
}

inline
void ParticleSystemBase::produceParticleGenerated(ParticleGeneratedEventDetailsType* const e)
{
    produceEvent(ParticleGeneratedEventId, e);
}

inline
boost::signals2::connection  ParticleSystemBase::connectParticleKilled(const ParticleKilledEventType::slot_type &listener, 
                                                                               boost::signals2::connect_position at)
{
    return _ParticleKilledEvent.connect(listener, at);
}

inline
boost::signals2::connection  ParticleSystemBase::connectParticleKilled(const ParticleKilledEventType::group_type &group,
                                                    const ParticleKilledEventType::slot_type &listener, boost::signals2::connect_position at)
{
    return _ParticleKilledEvent.connect(group, listener, at);
}

inline
void  ParticleSystemBase::disconnectParticleKilled(const ParticleKilledEventType::group_type &group)
{
    _ParticleKilledEvent.disconnect(group);
}

inline
void  ParticleSystemBase::disconnectAllSlotsParticleKilled(void)
{
    _ParticleKilledEvent.disconnect_all_slots();
}

inline
bool  ParticleSystemBase::isEmptyParticleKilled(void) const
{
    return _ParticleKilledEvent.empty();
}

inline
UInt32  ParticleSystemBase::numSlotsParticleKilled(void) const
{
    return _ParticleKilledEvent.num_slots();
}

inline
void ParticleSystemBase::produceParticleKilled(ParticleKilledEventDetailsType* const e)
{
    produceEvent(ParticleKilledEventId, e);
}

inline
boost::signals2::connection  ParticleSystemBase::connectParticleStolen(const ParticleStolenEventType::slot_type &listener, 
                                                                               boost::signals2::connect_position at)
{
    return _ParticleStolenEvent.connect(listener, at);
}

inline
boost::signals2::connection  ParticleSystemBase::connectParticleStolen(const ParticleStolenEventType::group_type &group,
                                                    const ParticleStolenEventType::slot_type &listener, boost::signals2::connect_position at)
{
    return _ParticleStolenEvent.connect(group, listener, at);
}

inline
void  ParticleSystemBase::disconnectParticleStolen(const ParticleStolenEventType::group_type &group)
{
    _ParticleStolenEvent.disconnect(group);
}

inline
void  ParticleSystemBase::disconnectAllSlotsParticleStolen(void)
{
    _ParticleStolenEvent.disconnect_all_slots();
}

inline
bool  ParticleSystemBase::isEmptyParticleStolen(void) const
{
    return _ParticleStolenEvent.empty();
}

inline
UInt32  ParticleSystemBase::numSlotsParticleStolen(void) const
{
    return _ParticleStolenEvent.num_slots();
}

inline
void ParticleSystemBase::produceParticleStolen(ParticleStolenEventDetailsType* const e)
{
    produceEvent(ParticleStolenEventId, e);
}

OSG_GEN_CONTAINERPTR(ParticleSystem);

OSG_END_NAMESPACE

